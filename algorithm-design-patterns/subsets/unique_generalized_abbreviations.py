"""
Given a word, write a function to generate all of its unique generalized abbreviations.
Generalized abbreviation of a word can be generated by replacing each substring of the word 
by the count of characters in the substring. 
Take the example of “ab” which has four substrings: “”, “a”, “b”, and “ab”. 
After replacing these substrings in the actual word by the count of characters we get 
all the generalized abbreviations: “ab”, “1b”, “a1”, and “2”.

Input: "BAT"
Output: "BAT", "BA1", "B1T", "B2", "1AT", "1A1", "2T", "3"

Input: "code"
Output: "code", "cod1", "co1e", "co2", "c1de", "c1d1", "c2e", "c3", "1ode", "1od1", "1o1e", "1o2", 
"2de", "2d1", "3e", "4"

"""
from typing import List
import pytest
from collections import deque


class AbbreviatedWord:
    def __init__(self, str, start, count):
        self.str = str
        self.start = start
        self.count = count


# so the overall time complexity of our algorithm will be O(N*2^N).
# All the additional space used by our algorithm is for the output list.
# Since we can’t have more than O(2^N) combinations, the space complexity of our algorithm is O(N*2^N).
def generate_generalized_abbreviation(word: str) -> List[str]:
    word_len = len(word)
    result = []
    queue = deque()
    queue.append(AbbreviatedWord(list(), 0, 0))
    while queue:
        ab_word: AbbreviatedWord = queue.popleft()
        if ab_word.start == word_len:
            if ab_word.count != 0:
                ab_word.str.append(str(ab_word.count))
            result.append("".join(ab_word.str))
        else:
            # continue abbreviating by incrementing the current abbreviation count
            queue.append(
                AbbreviatedWord(list(ab_word.str), ab_word.start + 1, ab_word.count + 1)
            )
            # restart abbreviating, append the count and the current character to the string
            if ab_word.count != 0:
                ab_word.str.append(str(ab_word.count))
            new_word = list(ab_word.str)
            new_word.append(word[ab_word.start])
            queue.append(AbbreviatedWord(new_word, ab_word.start + 1, 0))

    return result


test_data = [
    ("BAT", ["BAT", "BA1", "B1T", "B2", "1AT", "1A1", "2T", "3"]),
    (
        "code",
        [
            "code",
            "cod1",
            "co1e",
            "co2",
            "c1de",
            "c1d1",
            "c2e",
            "c3",
            "1ode",
            "1od1",
            "1o1e",
            "1o2",
            "2de",
            "2d1",
            "3e",
            "4",
        ],
    ),
]


@pytest.mark.parametrize("word, expected", test_data)
def test_generate_generalized_abbreviation(word: str, expected: List[str]):
    assert generate_generalized_abbreviation(word).sort() == expected.sort()
